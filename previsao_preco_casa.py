# -*- coding: utf-8 -*-
"""previsao_preco_casa

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vd0KWHIT-eccSBg2CvKRXtQM0jDPEIX6
"""

pip install scikit-learn

# Fórmula da regressão linear simples
# y = b0 + b1 * x

import pandas as pd
import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler

# Carregar os dados
base = pd.read_csv('house_prices.csv')

print(base.head())

# Selecionar as colunas corretas
x = base.iloc[:, 5].values.reshape(-1, 1)
y = base.iloc[:, 2:3].values

# Normalizar os dados
scaler_x = StandardScaler()
x = scaler_x.fit_transform(x)

scaler_y = StandardScaler()
y = scaler_y.fit_transform(y)

# Visualizar os dados
plt.scatter(x, y)
plt.show()

# Definir variáveis treináveis
b0 = tf.Variable(0.41, dtype=tf.float32)
b1 = tf.Variable(0.72, dtype=tf.float32)

# Criar tensores de entrada (diretamente como tensores de dados)
batch_size = 32

# Definir o modelo
def modelo(x):
    return b0 + b1 * x

# Função de erro (MSE)
mse = tf.keras.losses.MeanSquaredError()

# Otimizador SGD
otimizador = tf.keras.optimizers.SGD(learning_rate=0.001)

# Função de treinamento
def train_step(xph, yph):
    with tf.GradientTape() as tape:
        y_pred = modelo(xph)
        erro = mse(yph, y_pred)  # Calcula o erro

    # Calcula os gradientes da função de erro em relação às variáveis treináveis
    gradientes = tape.gradient(erro, [b0, b1])

    # Atualiza os pesos usando o otimizador
    otimizador.apply_gradients(zip(gradientes, [b0, b1]))

    return erro

# Loop de treinamento por 10000 iterações
for i in range(10000):
    indices = np.random.randint(len(x), size=batch_size)
    feed_x = x[indices]
    feed_y = y[indices]

    erro = train_step(feed_x, feed_y)

    # Exibindo o progresso de vez em quando
    if i % 1000 == 0:
        print(f"Iteração {i}: Erro = {erro.numpy()}")

# Exibindo os valores finais de b0 e b1
b0_final, b1_final = b0.numpy(), b1.numpy()
print("Valor final de b0:", b0_final)
print("Valor final de b1:", b1_final)

previsoes = b0_final + b1_final * x
plt.plot(x, y, 'o')
plt.plot(x, previsoes, color='red')
plt.show()

y1 = scaler_y.inverse_transform(y)
previsoes1 = scaler_y.inverse_transform(previsoes)
plt.plot(x, y1, 'o')
plt.plot(x, previsoes1, color='red')